![](res/algodeck.jpg)

<a href="https://www.buymeacoffee.com/teivah" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;" ></a>

## Overview

Algo Deck is an **open-source collection of +200 algorithmic flash cards**.

It helps you preparing and succeeding in your **algorithm & data structure interview**. The code examples are in Java.

The topics covered are the following:
- [Array](array.md): reversing an array, finding a pivot, handling a dynamic array, etc.  
- [Bit](bit.md): operators, bit manipulation, etc.
- [Complexity](complexity.md): algorithm & data structures complexity
- [Dynamic Programming](dynamicprogramming.md): dynamic programming concept
- [Encoding](encoding.md): encoding theory
- [General](general.md): general knowledge including how to approach a problem or testing a first solution
- [Graph](graph.md): A*, Dijkstra, BFS vs DFS, cycles detection, topological sort, etc.
- [Greedy](greedy.md): greedy algorithms concepts
- [Hash Table](hashtable.md): hashtable data structure
- [Heap](heap.md): heap data structure including min-heap/max heap, binary heap use cases, etc.
- [Linked List](linkedlist.md): linked list data structure, how to get the middle element, iterate over two lists, doubly linked list, etc.
- [Math](math.md): discrete math
- [Queue](queue.md): queue data structure
- [Recursion](recursion.md): recursion concepts
- [Sort](sort.md): sort algorithms including concepts, complexity, use cases, etc.
- [Stack](stack.md): stack data structure
- [String](string.md): string permutation, rotation, rabin-karp substring search, etc.
- [Technique](technique.md): most important techniques to master to solve algorithmic problems including greedy techniques, runner, sliding window, etc.
- [Tree](tree.md): binary tree use cases, binary search tree, 2-3 tree, red-black tree, use cases, etc. 

## Anki Deck

[Anki](https://apps.ankiweb.net/) is a free software (Windows/Mac/Linux/iPhone/Android) which makes remembering things easy. It utilizes spaced repetition which is a proven technique to increase the rate of memorization:  

[![](http://img.youtube.com/vi/-uMMRjrzPmE/0.jpg)](http://www.youtube.com/watch?v=-uMMRjrzPmE "Spaced Repetition: The most powerful study technique")

_Spaced Repetition: The most powerful study technique on YouTube_

> The single biggest change that Anki brings about is that it means memory is no longer a haphazard event, to be left to chance. Rather, it guarantees I will remember something, with minimal effort. That is, Anki makes memory a choice.

Michael A. Nielsen, "Augmenting Long-term Memory"

Thus, using Anki is a great way to prepare your algorithm & data structure interview.
Here is a flashcard example:

![](res/anki.png)

The **Anki version** (an Anki clone of the cards available in this repo) is available for $14.99:

[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_buynowCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=W4QQBV8VB4KZ8)

## Cards Index

### Array

* [Algorithm to reverse an array](array.md#algorithm-to-reverse-an-array)
* [Array complexity: access, search, insert, delete](array.md#array-complexity-access-search-insert-delete)
* [Binary search in a sorted array algorithm](array.md#binary-search-in-a-sorted-array-algorithm)
* [Find an element in a rotated sorted array](array.md#find-an-element-in-a-rotated-sorted-array)
* [Given an array, move all the 0 to the left while maintaining the order of the other elements](array.md#given-an-array-move-all-the-0-to-the-left-while-maintaining-the-order-of-the-other-elements)
* [How to detect if an element is a pivot in a rotated sorted array](array.md#how-to-detect-if-an-element-is-a-pivot-in-a-rotated-sorted-array)
* [How to find a pivot element in a rotated array](array.md#how-to-find-a-pivot-element-in-a-rotated-array)
* [How to find the duplicates in an array](array.md#how-to-find-the-duplicates-in-an-array)
* [How to manage a dynamic array](array.md#how-to-manage-a-dynamic-array)
* [How to test if the array is sorted in ascending or descending order](array.md#how-to-test-if-the-array-is-sorted-in-ascending-or-descending-order)
* [Rotate an array by n elements (n can be negative)](array.md#rotate-an-array-by-n-elements-n-can-be-negative)

### Bit

* [& operator](bit.md)
* [<< operator](bit.md)
* [>> operator](bit.md)
* [>>> operator](bit.md)
* [^ operator](bit.md)
* [Bit vector structure](bit.md#bit-vector-structure)
* [Check exactly one bit is set](bit.md#check-exactly-one-bit-is-set)
* [Clear bits from i to 0](bit.md#clear-bits-from-i-to-0)
* [Clear bits from most significant one to i](bit.md#clear-bits-from-most-significant-one-to-i)
* [Clear ith bit](bit.md#clear-ith-bit)
* [Flip ith bit](bit.md#flip-ith-bit)
* [Get ith bit](bit.md#get-ith-bit)
* [How to flip one bit](bit.md#how-to-flip-one-bit)
* [How to represent signed integers](bit.md#how-to-represent-signed-integers)
* [Set ith bit](bit.md#set-ith-bit)
* [Update a bit from a given value](bit.md#update-a-bit-from-a-given-value)
* [x & 0s](bit.md)
* [x & 1s](bit.md)
* [x & x](bit.md)
* [x ^ 0s](bit.md)
* [x ^ 1s](bit.md)
* [x ^ x](bit.md)
* [x | 0s](bit.md)
* [x | 1s](bit.md)
* [x | x](bit.md)
* [XOR operations](bit.md#xor-operations)
* [| operator](bit.md)
* [~ operator](bit.md)

### Complexity

* [0/1 Knapsack brute force complexity](complexity.md#01-knapsack-brute-force-complexity)
* [0/1 Knapsack memoization complexity](complexity.md#01-knapsack-memoization-complexity)
* [0/1 Knapsack tabulation complexity](complexity.md#01-knapsack-tabulation-complexity)
* [Amortized complexity definition](complexity.md#amortized-complexity-definition)
* [Array complexity: access, search, insert, delete](complexity.md#array-complexity-access-search-insert-delete)
* [B-tree complexity: access, insert, delete](complexity.md#b-tree-complexity-access-insert-delete)
* [BFS and DFS graph traversal time and space complexity](complexity.md#bfs-and-dfs-graph-traversal-time-and-space-complexity)
* [BFS and DFS tree traversal time and space complexity](complexity.md#bfs-and-dfs-tree-traversal-time-and-space-complexity)
* [Big O](complexity.md#big-o)
* [Big Omega](complexity.md#big-omega)
* [Big Theta](complexity.md#big-theta)
* [Binary heap (min-heap or max-heap) complexity: insert, get min (max), delete min (max)](complexity.md#binary-heap-min-heap-or-max-heap-complexity-insert-get-min-max-delete-min-max)
* [BST complexity: access, insert, delete](complexity.md#bst-complexity-access-insert-delete)
* [BST delete algo and complexity](complexity.md#bst-delete-algo-and-complexity)
* [Bubble sort complexity and stability](complexity.md#bubble-sort-complexity-and-stability)
* [Complexity of a function making multiple recursive subcalls](complexity.md#complexity-of-a-function-making-multiple-recursive-subcalls)
* [Complexity to create a trie](complexity.md#complexity-to-create-a-trie)
* [Complexity to insert a key in a trie](complexity.md#complexity-to-insert-a-key-in-a-trie)
* [Complexity to search for a key in a trie](complexity.md#complexity-to-search-for-a-key-in-a-trie)
* [Counting sort complexity, stability, use case](complexity.md#counting-sort-complexity-stability-use-case)
* [Doubly linked list complexity: access, insert, delete](complexity.md#doubly-linked-list-complexity-access-insert-delete)
* [Hash table complexity: search, insert, delete](complexity.md#hash-table-complexity-search-insert-delete)
* [Heapsort complexity, stability, use case](complexity.md#heapsort-complexity-stability-use-case)
* [Insertion sort complexity, stability, use case](complexity.md#insertion-sort-complexity-stability-use-case)
* [Linked list complexity: access, insert, delete](complexity.md#linked-list-complexity-access-insert-delete)
* [Mergesort complexity, stability, use case](complexity.md#mergesort-complexity-stability-use-case)
* [Quicksort complexity, stability, use case](complexity.md#quicksort-complexity-stability-use-case)
* [Radix sort complexity, stability, use case](complexity.md#radix-sort-complexity-stability-use-case)
* [Recursivity impacts on algorithm complexity](complexity.md#recursivity-impacts-on-algorithm-complexity)
* [Red-black tree complexity: access, insert, delete](complexity.md#red-black-tree-complexity-access-insert-delete)
* [Selection sort complexity](complexity.md#selection-sort-complexity)
* [Stack implementations and insert/delete complexity](complexity.md#stack-implementations-and-insertdelete-complexity)
* [Time complexity to build a binary heap](complexity.md#time-complexity-to-build-a-binary-heap)
* [Topological sort complexity](complexity.md#topological-sort-complexity)

### Dynamic Programming

* [Dynamic programming concept](dynamicprogramming.md#dynamic-programming-concept)
* [Memoization vs tabulation](dynamicprogramming.md#memoization-vs-tabulation)

### Encoding

* [ASCII charset](encoding.md#ascii-charset)
* [Difference encoding/charset](encoding.md#difference-encodingcharset)
* [Unicode charset](encoding.md#unicode-charset)

### General

* [Before finding a solution](general.md#before-finding-a-solution)
* [Comparator implementation to order two integers](general.md#comparator-implementation-to-order-two-integers)
* [Different ways for two intervals to relate to each other](general.md#different-ways-for-two-intervals-to-relate-to-each-other)
* [Different ways for two intervals to relate to each other if ordered by start then end](general.md#different-ways-for-two-intervals-to-relate-to-each-other-if-ordered-by-start-then-end)
* [Divide and conquer algorithm paradigm](general.md#divide-and-conquer-algorithm-paradigm)
* [How to name a matrix indexes](general.md#how-to-name-a-matrix-indexes)
* [If stucked on a problem](general.md#if-stucked-on-a-problem)
* [In place definition](general.md#in-place-definition)
* [P vs NP problems](general.md#p-vs-np-problems)
* [Solving optimization problems](general.md#solving-optimization-problems)
* [Stable property](general.md#stable-property)
* [What do to after having designed a solution](general.md#what-do-to-after-having-designed-a-solution)

### Graph
* [A* algorithm](graph.md#a-algorithm)
* [Backedge definition](graph.md#backedge-definition)
* [Best-first search algorithm](graph.md#best-first-search-algorithm)
* [BFS & DFS graph traversal use cases](graph.md#bfs-and-dfs-graph-traversal-time-and-space-complexity)
* [BFS and DFS graph traversal time and space complexity](graph.md#bfs--dfs-graph-traversal-use-cases)
* [Bidirectional search](graph.md#bidirectional-search)
* [Connected graph definition](graph.md#connected-graph-definition)
* [Difference Best-first search and A* algorithms](graph.md#difference-best-first-search-and-a-algorithms)
* [Dijkstra algorithm](graph.md#dijkstra-algorithm)
* [Dynamic connectivity problem](graph.md#dynamic-connectivity-problem)
* [Dynamic connectivity problem - Quick-find solution](graph.md#dynamic-connectivity-problem---quick-find-solution)
* [Dynamic connectivity problem - Quick-union solution](graph.md#dynamic-connectivity-problem---quick-union-solution)
* [Dynamic connectivity problem - Weighted Quick-union solution](graph.md#dynamic-connectivity-problem---weighted-quick-union-solution)
* [Given n tasks from 0 to n-1 and a list of relations so that a -> b means a must be scheduled before b, how to know if it is possible to schedule all the tasks (no cycle)](graph.md#given-n-tasks-from-0-to-n-1-and-a-list-of-relations-so-that-a---b-means-a-must-be-scheduled-before-b-how-to-know-if-it-is-possible-to-schedule-all-the-tasks-no-cycle)
* [Graph definition](graph.md#graph-definition)
* [Graph traversal: BFS](graph.md#graph-traversal-bfs)
* [Graph traversal: DFS](graph.md#graph-traversal-dfs)
* [How to compute the shortest path between two nodes in an unweighted graph](graph.md#how-to-compute-the-shortest-path-between-two-nodes-in-an-unweighted-graph)
* [How to detect a cycle in a directed graph](graph.md#how-to-detect-a-cycle-in-a-directed-graph)
* [How to detect a cycle in an undirected graph](graph.md#how-to-detect-a-cycle-in-an-undirected-graph)
* [How to name a graph with directed edges and without cycle](graph.md#how-to-name-a-graph-with-directed-edges-and-without-cycle)
* [How to name a graph with few edges and with many edges](graph.md#how-to-name-a-graph-with-few-edges-and-with-many-edges)
* [How to name the number of edges](graph.md#how-to-name-the-number-of-edges)
* [How to represent the edges of a graph (structure and complexity)](graph.md#how-to-represent-the-edges-of-a-graph-structure-and-complexity)
* [Topological sort complexity](graph.md#topological-sort-complexity)
* [Topological sort technique](graph.md#topological-sort-technique)
* [Travelling salesman problem](graph.md#travelling-salesman-problem)
* [Two types of graphs](graph.md#two-types-of-graphs)

### Greedy

* [Best-first search algorithm](greedy.md#best-first-search-algorithm)
* [Greedy algorithm](greedy.md#greedy-algorithm)
* [Greedy algorithm: structure](greedy.md#greedy-algorithm-structure)
* [Greedy technique](greedy.md#greedy-technique)
* [Technique - Optimization problems requiring a min or max](greedy.md#technique---optimization-problems-requiring-a-min-or-max)

### Hash Table

* [Hash table complexity: search, insert, delete](hashtable.md#hash-table-complexity-search-insert-delete)
* [Hash table implementation](hashtable.md#hash-table-implementation)

### Heap

* [Binary heap (min-heap or max-heap) complexity: insert, get min (max), delete min (max)](heap.md#binary-heap-min-heap-or-max-heap-complexity-insert-get-min-max-delete-min-max)
* [Binary heap (min-heap or max-heap) data structure used for the implementation](heap.md#binary-heap-min-heap-or-max-heap-data-structure-used-for-the-implementation)
* [Binary heap (min-heap or max-heap) definition](heap.md#binary-heap-min-heap-or-max-heap-definition)
* [Binary heap (min-heap or max-heap) delete min](heap.md#binary-heap-min-heap-or-max-heap-delete-min)
* [Binary heap (min-heap or max-heap) insert algorithm](heap.md#binary-heap-min-heap-or-max-heap-insert-algorithm)
* [Binary heap (min-heap or max-heap) use-cases](heap.md#binary-heap-min-heap-or-max-heap-use-cases)
* [Comparator implementation to order two integers](heap.md#comparator-implementation-to-order-two-integers)
* [Convert an array into a binary heap in place](heap.md#convert-an-array-into-a-binary-heap-in-place)
* [Find the median of a stream of numbers, 2 methods insert(int) and int findMedian()](heap.md#find-the-median-of-a-stream-of-numbers-2-methods-insertint-and-int-findmedian)
* [Given an unsorted array of numbers, find the K largest numbers in it](heap.md#given-an-unsorted-array-of-numbers-find-the-k-largest-numbers-in-it)
* [Heapsort algorithm](heap.md#heapsort-algorithm)
* [Is binary heap stable?](heap.md#is-binary-heap-stable)
* [Time complexity to build a binary heap](heap.md#time-complexity-to-build-a-binary-heap)
* [Two heaps technique](heap.md#two-heaps-technique)
* [Why binary heap over BST for priority queue?](heap.md#why-binary-heap-over-bst-for-priority-queue)

### Linked List

* [Algorithm to reverse a linked list](linkedlist.md#algorithm-to-reverse-a-linked-list)
* [Doubly linked list](linkedlist.md#doubly-linked-list)
* [Doubly linked list complexity: access, insert, delete](linkedlist.md#doubly-linked-list-complexity-access-insert-delete)
* [Get the middle of a linked list](linkedlist.md#get-the-middle-of-a-linked-list)
* [Iterate over two linked lists](linkedlist.md#iterate-over-two-linked-lists)
* [Linked list complexity: access, insert, delete](linkedlist.md#linked-list-complexity-access-insert-delete)
* [Linked list questions prerequisite](linkedlist.md#linked-list-questions-prerequisite)
* [Queue implementations and insert/delete complexity](linkedlist.md#queue-implementations-and-insertdelete-complexity)
* [Ring buffer (or circular buffer) structure](linkedlist.md#ring-buffer-or-circular-buffer-structure)
* [What if we need to iterate backwards on a singly linked list in constant space without mutating the input?](linkedlist.md#what-if-we-need-to-iterate-backwards-on-a-singly-linked-list-in-constant-space-without-mutating-the-input)

### Math

* [a = a property](math.md#a--a-property)
* [If a = b and b = c then a = c property](math.md#if-a--b-and-b--c-then-a--c-property)
* [If a = b then b = a property](math.md#if-a--b-then-b--a-property)
* [Logarithm definition](math.md#logarithm-definition)
* [Median of a sorted array](math.md#median-of-a-sorted-array)
* [n-choose-k problems](math.md#n-choose-k-problems)
* [Probability: P(a ∩ b) // inter](math.md#probability-pa--b--inter)
* [Probability: P(a ∪ b) // union](math.md#probability-pa--b--union)
* [Probability: Pb(a) // probability of a knowing b](math.md#probability-pba--probability-of-a-knowing-b)

### Queue

* [Dequeue data structure](queue.md#dequeue-data-structure)
* [Queue](queue.md#queue)
* [Queue implementations and insert/delete complexity](queue.md#queue-implementations-and-insertdelete-complexity)

### Recursion

* [How to handle a recursive function that need to return a list](recursion.md#how-to-handle-a-recursive-function-that-need-to-return-a-list)
* [How to handle a recursive function that need to return a maximum value](recursion.md#how-to-handle-a-recursive-function-that-need-to-return-a-maximum-value)
* [Loop inside of a recursive function?](recursion.md#loop-inside-of-a-recursive-function)

### Sort

* [Bubble sort algorithm](sort.md#bubble-sort-algorithm)
* [Bubble sort complexity and stability](sort.md#bubble-sort-complexity-and-stability)
* [Counting sort complexity, stability, use case](sort.md#counting-sort-complexity-stability-use-case)
* [Counting sort algorithm](sort.md#counting-sort-algorithm)
* [Heapsort algorithm](sort.md#heapsort-algorithm)
* [Heapsort complexity, stability, use case](sort.md#heapsort-complexity-stability-use-case)
* [Insertion sort algorithm](sort.md#insertion-sort-algorithm)
* [Insertion sort complexity, stability, use case](sort.md#insertion-sort-complexity-stability-use-case)
* [Mergesort algorithm](sort.md#mergesort-algorithm)
* [Mergesort complexity, stability, use case](sort.md#mergesort-complexity-stability-use-case)
* [Quicksort algorithm](sort.md#quicksort-algorithm)
* [Quicksort complexity, stability, use case](sort.md#quicksort-complexity-stability-use-case)
* [Radix sort algorithm](sort.md#radix-sort-algorithm)
* [Radix sort complexity, stability, use case](sort.md#radix-sort-complexity-stability-use-case)
* [Selection sort algorithm](sort.md#selection-sort-algorithm)
* [Selection sort complexity](sort.md#selection-sort-complexity)
* [Shuffling an array](sort.md#shuffling-an-array)

### Stack

* [Stack](stack.md#stack)
* [Stack implementations and insert/delete complexity](stack.md#stack-implementations-and-insertdelete-complexity)

### String

* [First check to test if two strings are a permutation or a rotation of each other](string.md#first-check-to-test-if-two-strings-are-a-permutation-or-a-rotation-of-each-other)
* [How to print all the possible permutations of a string](string.md#how-to-print-all-the-possible-permutations-of-a-string)
* [Rabin-Karp substring search](string.md#rabin-karp-substring-search)
* [String permutation vs rotation](string.md#string-permutation-vs-rotation)
* [String questions prerequisite](string.md#string-questions-prerequisite)

### Technique

* [0/1 Knapsack brute force technique](technique.md#01-knapsack-brute-force-technique)
* [0/1 Knapsack memoization technique](technique.md#01-knapsack-memoization-technique)
* [0/1 Knapsack tabulation technique](technique.md#01-knapsack-tabulation-technique)
* [Backtracking technique](technique.md#backtracking-technique)
* [Cyclic sort technique](technique.md#cyclic-sort-technique)
* [Greedy technique](technique.md#greedy-technique)
* [K-way merge technique](technique.md#k-way-merge-technique)
* [Runner technique](technique.md#runner-technique)
* [Simplification technique](technique.md#simplification-technique)
* [Sliding window technique](technique.md#sliding-window-technique)
* [Subsets technique](technique.md#subsets-technique)
* [Technique - Dealing with cycles in a linked list or an array](technique.md#technique---dealing-with-cycles-in-a-linked-list-or-an-array)
* [Technique - Find all the permutations or combinations](technique.md#technique---find-all-the-permutations-or-combinations)
* [Technique - Find an element in a sorted array or linked list](technique.md#technique---find-an-element-in-a-sorted-array-or-linked-list)
* [Technique - Find or calculate something among all the contiguous subarrays of a given size](technique.md#technique---find-or-calculate-something-among-all-the-contiguous-subarrays-of-a-given-size)
* [Technique - Find the longest/shortest substring or subarray](technique.md#technique---find-the-longestshortest-substring-or-subarray)
* [Technique - Find the smallest/largest/median element of a set](technique.md#technique---find-the-smallestlargestmedian-element-of-a-set)
* [Technique - Finding a certain element in a linked list (e.g. middle)](technique.md#technique---finding-a-certain-element-in-a-linked-list-eg-middle)
* [Technique - Given a sorted array, find a set of elements that fullfill certain conditions](technique.md#technique---given-a-sorted-array-find-a-set-of-elements-that-fullfill-certain-conditions)
* [Technique - Given an array of size n containing integer from 1 to n (e.g. with one duplicate)](technique.md#technique---given-an-array-of-size-n-containing-integer-from-1-to-n-eg-with-one-duplicate)
* [Technique - Given time intervals](technique.md#technique---given-time-intervals)
* [Technique - How to get the K biggest/smallest/frequent elements](technique.md#technique---how-to-get-the-k-biggestsmallestfrequent-elements)
* [Technique - Optimization problems requiring a min or max](technique.md#technique---optimization-problems-requiring-a-min-or-max)
* [Technique - Problems featuring a list of sorted arrays (merge or find the smallest element)](technique.md#technique---problems-featuring-a-list-of-sorted-arrays-merge-or-find-the-smallest-element)
* [Technique - Scheduling problem with n tasks where each task can have constraints to be completed before others](technique.md#technique---scheduling-problem-with-n-tasks-where-each-task-can-have-constraints-to-be-completed-before-others)
* [Technique - Situations like priority queue or scheduling](technique.md#technique---situations-like-priority-queue-or-scheduling)
* [Top K elements technique (biggest and smallest)](technique.md#top-k-elements-technique-biggest-and-smallest)
* [Topological sort technique](technique.md#topological-sort-technique)
* [Traversal technique](technique.md#traversal-technique)
* [Two heaps technique](technique.md#two-heaps-technique)
* [Two pointers technique](technique.md#two-pointers-technique)
* [What if we need to iterate backwards on a singly linked list in constant space without mutating the input?](technique.md#what-if-we-need-to-iterate-backwards-on-a-singly-linked-list-in-constant-space-without-mutating-the-input)

### Tree

* [2-3 tree](tree.md#2-3-tree)
* [AVL tree](tree.md#avl-tree)
* [B-tree complexity: access, insert, delete](tree.md#b-tree-complexity-access-insert-delete)
* [B-tree: definition and use case](tree.md#b-tree-definition-and-use-case)
* [Balanced binary tree definition](tree.md#balanced-binary-tree-definition)
* [Balanced BST use case: B-tree, Red-black tree, AVL tree](tree.md#balanced-bst-use-case-b-tree-red-black-tree-avl-tree)
* [BFS and DFS tree traversal time and space complexity](tree.md#bfs-and-dfs-tree-traversal-time-and-space-complexity)
* [Binary tree BFS traversal](tree.md#binary-tree-bfs-traversal)
* [Binary tree definition](tree.md#binary-tree-definition)
* [Binary tree DFS traversal: in-order, pre-order and post-order](tree.md#binary-tree-dfs-traversal-in-order-pre-order-and-post-order)
* [Binary tree: complete](tree.md#binary-tree-complete)
* [Binary tree: full](tree.md#binary-tree-full)
* [Binary tree: perfect](tree.md#binary-tree-perfect)
* [BST complexity: access, insert, delete](tree.md#bst-complexity-access-insert-delete)
* [BST definition](tree.md#bst-definition)
* [BST delete algo and complexity](tree.md#bst-delete-algo-and-complexity)
* [BST insert algo](tree.md#bst-insert-algo)
* [BST questions prerequisite](tree.md#bst-questions-prerequisite)
* [Complexity to create a trie](tree.md#complexity-to-create-a-trie)
* [Complexity to insert a key in a trie](tree.md#complexity-to-insert-a-key-in-a-trie)
* [Complexity to search for a key in a trie](tree.md#complexity-to-search-for-a-key-in-a-trie)
* [Given a binary tree, algorithm to populate an array to represent its level-by-level traversal](tree.md#given-a-binary-tree-algorithm-to-populate-an-array-to-represent-its-level-by-level-traversal)
* [How to calculate the path number of a node while traversing using DFS?](tree.md#how-to-calculate-the-path-number-of-a-node-while-traversing-using-dfs)
* [Min (or max) value in a BST](tree.md#min-or-max-value-in-a-bst)
* [Red-Black tree](tree.md#red-black-tree)
* [Red-black tree complexity: access, insert, delete](tree.md#red-black-tree-complexity-access-insert-delete)
* [Reverse a binary tree algo](tree.md#reverse-a-binary-tree-algo)
* [Trie definition, implementation and use case](tree.md#trie-definition-implementation-and-use-case)
* [Why to use BST over hash table](tree.md#why-to-use-bst-over-hash-table)
